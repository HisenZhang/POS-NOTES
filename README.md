
# The Principle of Operating System Based on Linux
> **POS - The Principle of Operating System Based on Linux**
>
> **This course is developed by Hisen at Dev - A , HFLS.**
>
> **Copyright 2017-2019(C). All rights reserved.**
>
> **Email : hisenzhang@gmail.com**



## 课程大纲

1. **Linux基础**
   1. 安装Linux
   2. Linux哲学
   3. 基础命令&操作

2. **操作系统概论**
   1. 处理器调度
   2. 内存管理
   3. 文件系统
   4. 进程管理
   5. 设备管理
   6. I/O

3. **Linux内核**
   1. 内核结构
   2. 编译内核

**Final Project**：

编译自己按需定制的内核，配置出个性化的操作系统  


## 正文章节


### **Linux**基础	

* **操作系统定义：**

  The layer of software between applications and the computer hardware that is responsible for managing the computer system.

* **操作系统的作用**：

1. 处理器调度：给不同任务分配系统资源
2. 内存管理：对内存空间的管理，分配
3. 文件系统：如何科学的组织，管理文件
4. 进程管理：如何分配，管理进程以及进程通信
5. 设备管理：对于设备的组织和管理
6. 输入输出– I/O：操作系统的输入输出管理，磁盘读写&网络

* **操作系统课题主要内容**

  ​# 处理器调度

  ​# 内存管理

  ​# 文件系统

  ​# 进程管理

  ​# 设备管理

  ​# I/O（Input& Output）

* **什么是Linux**

  > Linux是一种自由和开放源代码的类UNIX操作系统。目前运用最广泛使用人数最多的UNIX-Like操作系统。该操作系统的内核由林纳斯·托瓦兹Linus在1991年10月5日首次发布。

* **为什么以Linux为例讲解**

  Linux不像其他封闭系统，它的运行机制是完全可以观察和用户干预的。这一点给演示带来很大的便利。其次类Unix操作系统在科研领域运用广泛，学习好Linux有助于为其他计算机科学方向打好基础。  





#### **安装Linux**
1. 制作安装镜像.  利用dd命令 - Disk Duplicating把镜像复刻入启动设备如U盘 
   `dd if=~/Mint.iso of=/dev/sdb1`
2. 从启动设备启动（设置BIOS）
3. 安装Linux到硬盘 - 注意分区和文件系统格式。
4. 重启，第一次配置系统





#### **Linux哲学**

* Everything is a file ：一切皆文件
  Linux之所以如此成功，是因为它的设计思想“一切皆文件”：在Linux里所有的信息都是文件，包括了普通的文本文件，配置文件，设备文件等




#### 基础命令&操作

* **大小写敏感**
* **命令即程序**
  1. `ls` – 显示当前目录下的文件
  2. `cp` – 复制文件
  3. `mv` – 移动/重命名
  4. `rm` – 删除
  5. `chmod` – 改变文件权限
  6. `clear` – 清屏
  7. `exit` – 退出登录
  8. `poweroff` – 关机
  9. `reboot` – 重启
  10. `less/more/cat` – 查看文件



* **命令使用**：以`ls`为例

1. **作用：**列出当前目录下的所有文件 - List

2. **常用参数：**

  1. `-l`：Long

    给出当前目录下的所有文件的详细属性信息

  2. `-a`：All

    列出全部的文件，包括隐藏的．

    * 在Unix下隐藏文件以(.)开头

  3.  `-h`：Human-readable

    显示使人类可读（容量）

  4. `-t`：Time

    按时间(降序)排列文件

  5. `-r`：Reverse

    反转原先的排列顺序.可以反转时间排序或者是文件名排序

  6. __以上所有参数都可以组合使用__

    eg.	`ls -l -a` OR `ls -ls`

    __不能交换选项位置的情况__:当选项后面紧跟参数时.如

    `~$ tar -czf filename source `

    则此时f与c,z位置不能随意互换.

  7. 其他参数用法查阅帮助文档MAN - mannul

    命令    `man ls`/ `info ls`

    一般来说man的内容更加侧重使用,适合速查;info内容更全面细致.



#### 重定向和管道 - I : 一些有趣的小命令

1. `sl`
2. `fortune`
3. `cowsay`
4. `lolcat`
5. `pv -qL`
6. `figlet`
7. `morse`
8. `xeyes`




#### **重定向和管道 - 2 :命令的组合使用**

Linux下有很多功能单一但是强大的小工具.如何有效的组合使用这些工具是检验实战能力的标准之一. 注意利用好管道&重定向.



##### 重定向标准 - I/O Redirecting

Linux shell（比如Bash）接收或发送序列和字符串流*stream*形式的输入或输出. 每个字符都独立于与之相邻的字符. 字符没有被组织成结构化记录或固定大小的块. 不管实际的字符串流进入或来自文件、键盘、显示窗口或其他 I/O 设备, 都使用文件 I/O 技术来访问流.

**stdout是标准输出流**，它显示来自命令的输出.它的文件描述符为1

**stderr是标准错误流**，它显示来自命令的错误输出.它的文件描述符为2

**stdin是标准输入流**，它为命令提供输入.它的文件描述符为0

输入流通常通过终端击键为程序提供输入.输出流通常向终端输出文本字符.最初的终端是ASCII打字机或显示终端，但现在更多是指图形桌面上的文本窗口.

**标准输入在这里暂不涉及,只讲授其用法:从文件读入数据.**



##### **重定向输出**

两种方法将输出重定向到文件：

**1.`n > file`**

将输出从文件描述符n重定向到文件。您必须具有该文件的写权限。如果该文件不存在，将创建它。如果该文件已经存在，通常**将覆盖**所有现有内容，并且没有任何警告。

**2.`n >> file`**

还可以将输出从文件描述符n重定向到一个文件中。这里也一样要求您具有该文件的写权限。如果该文件不存在，将创建它。如果该文件已经存在，输出**将附加到**现有的内容后面。

*****在`n>`或`n>>`中的n引用文件描述符。如果省略它，将执行标准输出。如，`ls> log.txt` 把原本输出到屏幕的ls信息重定向到一个log.txt的文件。查看这个文件就可以得到ls的输出结果。

*****有时候要完全忽略标准输出或标准错误。为此，将选择的流重定向到空文件`/dev/null`**(null是黑洞设备,会丢弃一切写入的数据.)**

`~$ ls > /dev/null`

从ls命令忽略错误输出，同时也使用cat命令显示/dev/null是空的:

`~$ cat /dev/null`

##### **通过管道将stdout导入到stdin**

在两个命令之间使用**管道  |  操作符**将的一个命令的stdout指向第二个命令的stdin

管道可以被接的很长:添加更多的命令和管道操作符来构造更长的管道线.

*任何命令都可能包含选项或参数.*

构造由多个命令（每个命令都有特定的功能）组成的长管道线是在Linux和UNIX®中用于完成任务的常见方法。

`command1| command2 paramater1 `



**分析一个long-pipeline**,例如,
```bash
~$ ls -l | cowsay | lolcat

# ls-l的标准输出传入作为cowsay的标准输入;接着cowsay的输出(包含有ls信息的奶牛字符画)作为lolcat的标准输入,加上彩虹色作为最终的输出.

# 这里的-l就是ls命令的parameter(参数/选项).
```
需要说明的是，管道线仅将stdout导向stdin,不能单独导出stderr。如果stderr已被重定向到stdout，那么两个流都会被通过管道导出。也就是说,如果上个例子中ls出错(ls了一个不存在的目录/文件,等等),标准错误信息没有被传到下一个stdin,而是什么都没有传到后者.因此最终的输出不包含NOSUCH FILE OR DIRECTORY之类的错误信息.



##### 构建文件开始的管道线 - pipeline

对第一个命令使用**输入重定向**，然后在剩余的管道下中导出该命令的输出。仅需使用**<****操作符**将第一个命令的stdin重定向到需要处理的文件

如
```bash
~$ rev &lt; INPUT

# 将文件file的内容读取,**按行**逐个字符颠倒(交换位置),July2017变为7102yluJ .输出结果在终端(屏幕).
```
而
```bash
~$ rev &lt; INPUT &gt; OUTPUT

# 如上面一条命令,将文件file的内容读取,逐个字符颠倒(交换位置),最后把结果写入文件OUTPUT.
```

类似地,`~ $ rev < INPUT > INPUT`作用 如上面一条命令,将文件file的内容读取,逐个字符颠倒(交换位置),**最后把结果覆盖源文件**INPUT.



##### 长管道命令示范(了解即可)

```bash
~$ rev< CAL | cowsay | lolcat > file
~$ cat file
```

运行结果截图:

![1501086378049](/home/hisenzhang/Documents/DEV-A/POS/pics/1501086378049.png)

**解释:** 相当于把文件CAL的内容作为rev的标准输入,再把rev的标准输出作为cowsay的标准输入...以此类推.最后把输出重定向到文件,我们发现,这个pipeline的本质是读取一个文件,对其进行某种加工,最终再写回文件的操作.



##### 使用管道+grep来过滤关键字

```bash

~ $ ls | grep Qt

列举所有当前目录下的文件并筛选出文件名包含有Qt的行
```



grep 管道可以帮助筛选,选出所带参数的文本信息

其他类似的用法还有
```bash
~ $ ps -aux | grep vim	

# 查看所有与vim(一个终端下的文本编辑器)相关的进程信息
```

#### **一些进阶工具的基本使用方法:放手开始实战之前的最后一部分**

在正真开始Hard模式之前,我们需要升级一下武器装备.之前的十条命令非常基础非常重要,但第二大板块的内容会需要用到一些更加高级的工具来辅助.

##### **文本查看+编辑 - less/more/cat → vim**

原先提到的less/more/cat是文本查看器,只能查看内容而不能更改内容.

vim是文本编辑器VIiMproved的缩写可以查看+编辑.相较其原先版本,vim跟接近现代的使用方法.

###### a.基本用法 `~ $ vim filename`

如果存在这个文件则打开;不存在则新建一个.

###### b.界面状态

两种主要的工作模式有着不同的功能available(可用):

命令模式(编辑)vs插入模式(输入)

- **模式判别:**

若屏幕左下角有--INSERT--字样说明在编辑模式下;键入冒号,如屏幕左下角有冒号跳出并允许键入命令,则处于命令模式.

- **切换模式:**

插入模式下可以对文本内容进行输入;命令模式支持编辑.

*#**命令模式→插入模式** :*在命令模式下按i键– Istands for INSERT.

*#**插入模式→ 命令模式 **:*按ESC建.

**在任何模式下,一路按ESC都能回到命令模式;此时再按一下 i 键便进入插入模式.**

###### c.保存并退出

在命令模式键入:q即退出.

如果对文件做了修改modify,则会询问保存否.

`:wq`    # Want to save changes and Quit 存盘并退出

`:q!`    # Quit anyway! 这时候不保存修改.



### 操作系统概论


#### 处理器调度

调度在计算机中是分配工作所需资源的方法.资源可以指虚拟的计算资源，如**线程、进程**或数据流；也可以指硬件资源，如**处理器**、网络连接或扩展卡.这里我们以处理器的调度为例进行讲解.

进行调度工作的程序叫做**调度器**。.度器通常的实现使得所有计算资源都处于忙碌状态（负载均衡），允许多位用户有效地同时共享系统资源，或达到指定的服务质量。调度是计算自身的基础，同时也是编程语言计算模型固有的部分.调度器使得在单处理器上通过多任务处理，从而让执行多个进程成为可能.

调度器可能会针对不同的目标设计，例如：吞吐率最大化、响应时间最小化、最低延迟、或最大化公平.在实践中，这些目标通常是互相冲突的，因此，调度器会实现一个权衡利弊的折中方案，而侧重点则可能是前文提到的任何一种，这取决于用户的需求和目的.

调度也可能是通过一个管理性的后端进行，而任务是通过网络发配到若干远程设备上的.(分布式)



##### 进程 & 线程: 工厂与车间

两者属于易混淆概念,学习是注意区分.需要掌握两者异同.

我们以一个例子来了解:(改写自阮一峰的博文)

计算机的核心是CPU,承担了所有的计算任务.这好比一座工厂,时刻在运行.

这座工厂下设许多个车间.但是工厂的供电有限,当一个车间开工时其他必须全部停工.也就是说,**单个CPU一次只能运行一个任务**.

而进程就好比工厂的车间.在任意时刻,CPU总是只能运行一个进程,其他进程处于非运行状态.

一个车间里可以有很多的工人.他们协同完成一个任务.线程就好比车间里的工人.一个进程可以包含多个线程.

车间的空间是所有工人共享的.一个进程是共享的,每个线程都可以使用这些共享的内存.

但是每个房间的大小不同,有些房间只能容纳一人,比如厕所.当一个线程使用某些共享内存的时候,其他线程必须等待他结束才能使用这一块内存.

一个防止他人进入的简单方法就是给门加锁.先到的人进去,锁上.后来的人看到锁就先排队,等锁打开再进去.这就是互斥锁(MutualExclusion, Mutex),防止多线程同时读写内存某块区域.

有些房间如厨房,可以同时容纳一定人数.多出来的人要在外面等着.某些内存区域只能让固定数目的线程使用.

这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处.后到的人发现钥匙架空了，就知道必须在门口排队等着了.这种做法叫做"信号量"（Semaphore），用来保证多个线程不会互相冲突.

不难看出，mutex是semaphore的一种特殊情况（n=1时.也就是说，完全可以用后者替代前者.**但是，因为mutex较为简单**，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计.



##### 进程的特征

动态性：进程是程序的执行，同时进程有生命周期。

并发性：多个进程可同存于内存中，能在一段时间内同时执行。

独立性：资源分配和调度的基本单位。

制约性：并发进程间存在制约关系，造成程序执行速度不可预测性，必须对进程的并发执行次序、相对执行速度加以协调。

结构特征：进程由程序块、数据块、进程控制块三部分组成。



##### 进程的三种基本状态

1. 运行态(running)

  当进程得到处理机，其执行程序正在处理机上运行时的状态称为运行状态。

  在单CPU系统中，任何时刻最多只有一个进程处于运行状态。在多CPU系统中，处于运行状态的进程数最多为处理机的数目。

2. 就绪状态(ready)

  当一个进程已经准备就绪，一旦得到CPU，就可立即运行，这时进程所处的状态称为就绪状态。系统中有一个就绪进程队列，处于就绪状态进程按某种调度策略存在于该队列中。

3. 等待态（阻塞态）（Wait/ Blocked ）

  若一个进程正等待着某一事件发生(如等待输入输出操作的完成)而暂时停止执行的状态称为等待状态。     处于等待状态的进程不具备运行的条件，即使给它CPU，也无法执行。系统中有几个等待进程队列（按等待的事件组成相应的等待队列）。



##### 调度设计三要点

1. 以多进程形式，允许多个任务同时运行；

2. 以多线程形式，允许单个任务分成不同的部分运行；

3. 提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。